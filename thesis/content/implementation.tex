\chapter{Implementation}
The implementation of the algorithm is done in the Rust programming language \footnote{\href{rust-lang.org/}{rust-lang.org/}} and contained in the git sub module \mintinline{sh}{spam-align} of the alignment evaluation folder.\\


The core part of the algorithm as described in \ref{chap:algorithm} is designed to iteratively maintain a partial alignment, as per definition \ref{def:alignment}, that allows the fast insertion of newly aligned sites as well as checking if a given pair of sites is consistent with the given alignment.\\
An initial implementation is part of the \textit{Dialign2.2} program
\begin{itemize}
	\item explain 
\end{itemize}

% TODO should this be here or in appendix?
\begin{multicols}{2}
\begin{minted}[tabsize=1]{rust}
pub struct Closure {
	sequences: Sequences,
	alig_set: Matrix<usize>,
	
	nbr_alig_sets: usize,
	old_nbr_alig_sets: usize,
	
	pred_frontier: Matrix<usize>,
	succ_frontier: Matrix<usize>,
	
	pred_frontier_ops: Vec<FrontierOp>,
	succ_frontier_ops: Vec<FrontierOp>,
}
\end{minted}

\begin{minted}[tabsize=2]{rust}
struct Sequences {
	lengths: Vec<usize>,
	alig_set_nbr: Matrix<usize>,
	pred_alig_set_pos: Matrix<usize>,
	succ_alig_set_pos: Matrix<usize>,
}
\end{minted}
\captionof{listing}{Data types responsible for storing partial alignment information.}
\label{lst:core-types}
\end{multicols}

Listing \ref{lst:core-types} provides the definition of the core data types responsible for tracking the status of an alignment that is constructed by iteratively aligning sites. A \mintinline{rust}{struct} in Rust functions as simple record of heterogeneous data similar to those in the \textit{C} programming language. Members of a \mintinline{rust}{struct} are defined as \code{<name of member field>: <type of field>}.\\
\mintinline{rust}{alig_set: Matrix<usize>} is a 2-dimensional matrix implementation containing \mintinline{rust}{usize} elements, which are usigned integers with a size equal to the target architecture pointer size (meaning 64 bits on a 64 bit target). 


Differences to Gabios-Lib
\begin{itemize}
	\item matrices are contiguous memory instead of pointer of pointers -> reduces indirection and improves cache locality
	\item no unnecessary left and right buffers which need to be written each iteration
	\item frontier ops instead of pos matrix allows applying frontier changes in $O(\#changes)$ instead of $O(\#seq^2 * \text{part in while loop, don't know upper bound})$
	\item sequences is struct of matrices instead of Vec of struct of vecs -> less indirection
\end{itemize}

